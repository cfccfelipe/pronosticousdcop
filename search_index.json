[["index.html", "Pronóstico USD/COP Capitulo 1 Fuente de información", " Pronóstico USD/COP Carlos Felipe Cortés Cataño - Roy Díaz Vega 2023-05-18 Capitulo 1 Fuente de información Los precios de cierre diarios del presente prónostico son obtenidos usando el API provisionado por Yahoo Finance. La codificación es realizada usando el lenguaje de programación Python, sin embargo, se usa la aplicación R Markdown para compilar el libro “bookdown”. El modulo para obtener los datos es llamado “yfinance”, más información en https://pypi.org/project/yfinance/. "],["intro.html", "Capitulo 2 Introducción", " Capitulo 2 Introducción La importancia de pronosticar la tasa de cambio del Peso Colombiano (COP) con el Dolar Americano (USD) radica en el impacto significativo en la economía y los negocios de un país. Algunas de las razones por las cuales es importante pronosticar la tasa de cambio de una divisa incluyen: Comercio internacional: Las empresas que realizan negocios internacionales se ven afectadas por las fluctuaciones en las tasas de cambio, ya que estas pueden afectar el costo de los bienes y servicios importados y exportados. Un pronóstico preciso de las tasas de cambio puede ayudar a las empresas a planificar mejor sus estrategias de comercio internacional. Inversión extranjera: Los inversores extranjeros que desean invertir en un país se ven afectados por las tasas de cambio, ya que estas pueden afectar el retorno de su inversión. Un pronóstico preciso de las tasas de cambio puede ayudar a los inversores a tomar decisiones informadas sobre dónde invertir su dinero. Turismo: Las tasas de cambio también pueden tener un impacto en el turismo, ya que pueden afectar el costo de los viajes y los bienes y servicios relacionados con el turismo. Un pronóstico preciso de las tasas de cambio puede ayudar a los turistas a planificar mejor sus viajes y presupuestos. Política monetaria: Los gobiernos y los bancos centrales también pueden utilizar la información sobre las tasas de cambio para formular políticas monetarias. Un pronóstico preciso de las tasas de cambio puede ayudar a los responsables de la formulación de políticas a tomar decisiones informadas sobre las tasas de interés y otros instrumentos de política monetaria. En resumen, el análisis y pronóstico de este par de divisas es importante porque puede afectar la economía y los negocios de un país como Colombiano, así como las decisiones de inversión, turismo y política monetaria. Un pronóstico preciso de las tasas de cambio puede ayudar a las empresas, inversores y responsables de la formulación de políticas a tomar decisiones informadas. "],["get.html", "Capitulo 3 Obtención de datos", " Capitulo 3 Obtención de datos #Install dependencies if not available #py_install(&quot;reticulate&quot;,yfinance&quot;) #install.packages(&quot;reticulate&quot;) library(reticulate) Sys.setenv(RETICULATE_PYTHON=&quot;C:/Users/carlos/anaconda3&quot;) Sys.getenv(&quot;RETICULATE_PYTHON&quot;) ## [1] &quot;C:/Users/carlos/anaconda3&quot; import yfinance as yf data = yf.download(&quot;COP=X&quot;, start=&quot;2017-01-01&quot;, end=&quot;2022-12-31&quot;) ## [*********************100%***********************] 1 of 1 completed data.to_csv(&quot;data.csv&quot;) data.head() ## Open High ... Adj Close Volume ## Date ... ## 2017-01-02 3000.250000 3000.949951 ... 2957.100098 0 ## 2017-01-03 3004.149902 3004.149902 ... 2950.699951 0 ## 2017-01-04 2999.949951 2999.949951 ... 2916.199951 0 ## 2017-01-05 2902.000000 2969.399902 ... 2891.100098 0 ## 2017-01-06 2941.550049 2941.550049 ... 2897.899902 0 ## ## [5 rows x 6 columns] "],["preliminar.html", "Capitulo 4 Analisis Preliminar", " Capitulo 4 Analisis Preliminar import yfinance as yf import pandas as pd import matplotlib.pyplot as plt # Descargar los datos data = yf.download(&quot;COP=X&quot;, start=&quot;2017-01-01&quot;, end=&quot;2022-12-31&quot;) # Obtener el año de cada fecha ## [*********************100%***********************] 1 of 1 completed data[&#39;Year&#39;] = data.index.year # Estadísticas descriptivas por años yearly_stats = data.groupby(&#39;Year&#39;)[&#39;Close&#39;].describe() # Graficar boxplots por año plt.figure(figsize=(10, 6)) data.boxplot(column=&#39;Close&#39;, by=&#39;Year&#39;, vert=False) plt.xlabel(&#39;Precio de cierre&#39;) plt.ylabel(&#39;Año&#39;) plt.title(&#39;Gráfico de caja y bigotes por año - Precio de cierre de COP=X&#39;) plt.grid(True) # Graficar dispersión de precios de cierre por año plt.figure(figsize=(10, 6)) for year, year_data in data.groupby(&#39;Year&#39;): plt.scatter(year_data.index, year_data[&#39;Close&#39;], label=str(year), alpha=0.7) plt.xlabel(&#39;Fecha&#39;) plt.ylabel(&#39;Precio de cierre&#39;) plt.title(&#39;Dispersión de precios de cierre por año - COP=X&#39;) plt.legend(title=&#39;Año&#39;) plt.grid(True) plt.show() Inicialmente, se presenta graficos descriptivos sobre el precio de cierre del precio de peso colombiano (COP) con relación al dolar estado unidense (USD). Se observa, en el diagrama de cajas y bigotes, que el precio tiene fluaciones regulares en los deferentes años, sin valores atipicos destacables, con incrementos con el paso de los años. Es de anotar que la mayor amplitud de los datos de precio, y por tanto una mayor fluctuación de la tasa, se presenta en el reciente año 2022. Para el grafico de dispesión en los años evaluados, se muestra claramente el ascenso de la tasa de cambio COL/USD. Mostrandose con mayor dispersión de los datos en los años 2020 y 2022. "],["ma.html", "Capitulo 5 Medias Moviles", " Capitulo 5 Medias Moviles import plotly.graph_objects as go # Calcular la media móvil para diferentes periodos periodos = [10, 20, 40, 80, 100] sma_traces = [] # Lista para almacenar las trazas de las medias móviles data = data.reset_index() for periodo in periodos: sma = data[&quot;Close&quot;].rolling(periodo).mean() sma_trace = go.Scatter(x=data[&quot;Date&quot;], y=sma, name=f&quot;SMA {periodo} Periodos&quot;) sma_traces.append(sma_trace) # Crear la figura y agregar las trazas de las medias móviles sma_graph = go.Figure(sma_traces) # Agregar la gráfica del precio de cierre original sma_graph.add_trace(go.Scatter(x=data[&quot;Date&quot;], y=data[&quot;Close&quot;], name=&quot;Precio de cierre&quot;)) # Mostrar el gráfico sma_graph.show() El gráfico muestra las medias móviles con ventanas de 10, 20, 40, 80 y 100 períodos en relación al precio de cierre. Se puede observar que cada una de estas medias móviles se ajusta bastante cerca de los datos del precio de cierre. Sin embargo, se nota que la media móvil con una ventana de 100 períodos muestra un ajuste ligeramente menor, lo cual es comprensible debido a la amplitud de la ventana utilizada. import plotly.graph_objects as go import pandas as pd import plotly.graph_objects as go # Calcular la media móvil periodo_corto = 50 periodo_largo = 200 data[&quot;SMA_corto&quot;] = data[&quot;Close&quot;].rolling(periodo_corto).mean() data[&quot;SMA_largo&quot;] = data[&quot;Close&quot;].rolling(periodo_largo).mean() # Señales de compra y venta basadas en las medias móviles data[&quot;Senal_compra&quot;] = (data[&quot;SMA_corto&quot;] &gt; data[&quot;SMA_largo&quot;]) &amp; (data[&quot;SMA_corto&quot;].shift() &lt;= data[&quot;SMA_largo&quot;].shift()) data[&quot;Senal_venta&quot;] = (data[&quot;SMA_corto&quot;] &lt; data[&quot;SMA_largo&quot;]) &amp; (data[&quot;SMA_corto&quot;].shift() &gt;= data[&quot;SMA_largo&quot;].shift()) # Crear el gráfico fig = go.Figure() # Agregar la gráfica del precio de cierre fig.add_trace(go.Scatter(x=data[&quot;Date&quot;], y=data[&quot;Close&quot;], name=&quot;Precio de cierre&quot;, line=dict(color=&quot;blue&quot;))) # Agregar las medias móviles corta y larga fig.add_trace(go.Scatter(x=data[&quot;Date&quot;], y=data[&quot;SMA_corto&quot;], name=f&quot;SMA {periodo_corto} Periodos&quot;, line=dict(color=&quot;orange&quot;))) fig.add_trace(go.Scatter(x=data[&quot;Date&quot;], y=data[&quot;SMA_largo&quot;], name=f&quot;SMA {periodo_largo} Periodos&quot;, line=dict(color=&quot;green&quot;))) # Agregar las señales de compra y venta fig.add_trace(go.Scatter(x=data[data[&quot;Senal_compra&quot;]][&quot;Date&quot;], y=data[data[&quot;Senal_compra&quot;]][&quot;Close&quot;], name=&quot;Señal de compra&quot;, mode=&quot;markers&quot;, marker=dict(color=&quot;green&quot;, symbol=&quot;triangle-up&quot;, size=10))) fig.add_trace(go.Scatter(x=data[data[&quot;Senal_venta&quot;]][&quot;Date&quot;], y=data[data[&quot;Senal_venta&quot;]][&quot;Close&quot;], name=&quot;Señal de venta&quot;, mode=&quot;markers&quot;, marker=dict(color=&quot;red&quot;, symbol=&quot;triangle-down&quot;, size=10))) # Mostrar el gráfico fig.show() En este grafico, como un primer intento se uso practico, utilizamos la media móvil como una señal de compra y venta. Cuando la media móvil corta cruza por encima de la media móvil larga, se genera una señal de compra, y cuando la media móvil corta cruza por debajo de la media móvil larga, se genera una señal de venta. Estas señales se muestran en el gráfico junto con las medias móviles y el precio de cierre original. "],["desco.html", "Capitulo 6 Descomposición", " Capitulo 6 Descomposición #Manipulation import pandas as pd import numpy as np import datetime from statsmodels.tsa.seasonal import seasonal_decompose #Visualization import matplotlib.pyplot as plt from plotly.subplots import make_subplots import plotly.express as px import plotly.graph_objects as go data = pd.read_csv(&quot;data.csv&quot;) print(data.head(3)) ## Date Open High ... Close Adj Close Volume ## 0 2017-01-02 3000.250000 3000.949951 ... 2957.100098 2957.100098 0 ## 1 2017-01-03 3004.149902 3004.149902 ... 2950.699951 2950.699951 0 ## 2 2017-01-04 2999.949951 2999.949951 ... 2916.199951 2916.199951 0 ## ## [3 rows x 7 columns] Se muestran las seríe de tiempo para los precios de apertura, cierre, máximo y mínimo del 1 de enero de 2017 al 31 de diciembre de 2022, los cuales visualizaremos y compararemos a continuación: serie_graph = make_subplots(rows=2, cols=2,x_title=&quot;Precio(COP)&quot;,y_title=&quot;Fecha&quot;, subplot_titles=(&#39;Apertura&#39;,&quot;Cierre&quot;, &#39;Máximo&#39;, &#39;Mínimo&#39;)) s1 = go.Scatter(x=data[&quot;Date&quot;],y=data[&quot;Open&quot;].values,marker_color=&#39;black&#39;) s2 = go.Scatter(x=data[&quot;Date&quot;],y=data[&quot;High&quot;].values, marker_color=&#39;black&#39;) s3 = go.Scatter(x=data[&quot;Date&quot;],y=data[&quot;Low&quot;].values, marker_color=&#39;black&#39;) s4 = go.Scatter(x=data[&quot;Date&quot;],y=data[&quot;Close&quot;].values, marker_color=&#39;black&#39;) serie_graph.append_trace(s1,1, 1) serie_graph.append_trace(s4, 1, 2) serie_graph.append_trace(s2, 2, 1) serie_graph.append_trace(s3, 2, 2) serie_graph.update_layout( font=dict( family=&quot;Roboto&quot;, size=14, color=&quot;#1A2747&quot; ), showlegend=False) serie_graph.show() Las cuatro series parecen compartarse de una manera muy similar, sin embargo, los precios mínimos parecen tener un comportamiento más estable, aunque, hay unos valores atipicos que hacen que el eje vertical inicie desde el nivel 0. En esas condiciones, a partir de aquí solo tenemos en cuenta precios de cierre que son los que normalmente se desean pronosticar para encontrar comportamientos en la serie. pd.plotting.lag_plot(data[&quot;Close&quot;], lag=12) Con un resago de 12 periodos que en este caso son días, logramos ver la serie autocorrelacionada y muy pocos puntos se evidencias aleatorios, gráficaremos de nuevo con 55 periodos. pd.plotting.lag_plot(data[&quot;Close&quot;], lag=55) Con 55 periodos vemos más puntos alejados del comportamiento que ha venido teniendo la serie en especial para los niveles de 4500 en adelante.Veamos el comportamiento de una media movil simple de 55 periodos para esta serie. import plotly.graph_objects as go sma_graph = go.Figure(go.Scatter(x=data[&quot;Date&quot;], y=data[&quot;Close&quot;].rolling(55).mean(), marker_color=&#39;black&#39;,name=&quot;Tendencia 55 Periodos&quot;)) sma_graph.add_trace(go.Scatter(x=data[&quot;Date&quot;], y=data[&quot;Close&quot;], name=&quot;Precio de cierre&quot;)) sma_graph.show() A partir de abril de 2022 se nota una tendencia no cambiante frente al precio del dolar basada en los 55 ultimos periodos. Finalmente, si vemos esos cambios de precio podemos observar el siguiente gráfico resago55_graph = go.Figure(go.Scatter(x=data[&quot;Date&quot;],y=data[&quot;Close&quot;].diff(periods=55),marker_color=&#39;black&#39;)) resago55_graph.show() Podría parecer que los cambios de precios más fuertes se han dado en el ultimo año, sin embargo, con esta gráfica notamos que fueron en marzo de 2020, el año donde llego la pandemía. Finalmente revisemos la descomposición de esta serie teniendo en cuenta el periodo de 365 días. decomposition = seasonal_decompose(np.log(data[&quot;Close&quot;]), model=&#39;additive&#39;, period=365) data[&quot;dec_trend_365&quot;]=decomposition.trend data[&quot;dec_seasonal_365&quot;]=decomposition.seasonal data[&quot;dec_residuals_365&quot;]=decomposition.resid descomposicion = make_subplots(rows=3, cols=1, x_title=&quot;Variable&quot;, y_title=&quot;&quot;,subplot_titles=(&#39;Trend&#39;, &#39;Seasonal&#39;, &#39;Residuals&#39;)) dc1 = go.Scatter(x=data[&quot;Date&quot;], y=data[&quot;dec_trend_365&quot;].values,marker_color=&#39;black&#39;) dc2 = go.Scatter(x=data[&quot;Date&quot;],y=data[&quot;dec_seasonal_365&quot;].values, marker_color=&#39;black&#39;) dc3 = go.Scatter(x=data[&quot;Date&quot;],y=data[&quot;dec_residuals_365&quot;].values, name= &quot;&quot;, marker_color=&#39;black&#39;) descomposicion.append_trace(dc1,1, 1) descomposicion.append_trace(dc2, 2, 1) descomposicion.append_trace(dc3, 3, 1) descomposicion.update_layout( font=dict( family=&quot;Roboto&quot;, size=14, color=&quot;#1A2747&quot; ), margin=dict(l=0, r=0, b=0, t=80), showlegend=False, height = 700, title_x=0.5, paper_bgcolor=&#39;white&#39;, plot_bgcolor=&#39;white&#39;, hovermode=&#39;closest&#39;,) descomposicion.show() Vemos una tendecia constante al alza, con una estacionalidad que se presenta aproximadamente cada 16 meses, sin embargo, los residuos que estamos obteniendo no parecen ser aleatorios completamiente. Esta frecuencia se podría ser verificada con mayor detalle más adelante. "],["metodo-holt-winter-hw.html", "Capitulo 7 Metodo Holt-Winter {#h&amp;w}", " Capitulo 7 Metodo Holt-Winter {#h&amp;w} import pandas as pd import statsmodels.api as sm import matplotlib.pyplot as plt # Preparar los datos para el análisis de Holt-Winters data[&quot;Date&quot;] = pd.to_datetime(data[&quot;Date&quot;]) data.set_index(&quot;Date&quot;, inplace=True) values = data[&quot;Adj Close&quot;] # Aplicar el modelo de Holt-Winters y obtener los valores ajustados model = sm.tsa.ExponentialSmoothing(values, trend=&quot;add&quot;, seasonal=&quot;add&quot;, seasonal_periods=12) ## C:\\Users\\carlos\\ANACON~1\\lib\\site-packages\\statsmodels\\tsa\\base\\tsa_model.py:471: ValueWarning: ## ## A date index has been provided, but it has no associated frequency information and so will be ignored when e.g. forecasting. results = model.fit() fitted_values = results.fittedvalues # Graficar los valores reales y los valores ajustados plt.figure(figsize=(12, 6)) plt.plot(data.index, values, label=&quot;Valores reales&quot;) plt.plot(data.index, fitted_values, label=&quot;Valores ajustados&quot;) plt.xlabel(&quot;Fecha&quot;) plt.ylabel(&quot;Valor&quot;) plt.title(&quot;Ajuste de Holt-Winters&quot;) plt.legend() plt.show() En el grafico muestra la aplicación el método de Holt-Winters a los datos de precios de cierre ajustados con los valores reales y los valores ajustados por el modelo. import pandas as pd import statsmodels.api as sm import matplotlib.pyplot as plt # Aplicar el modelo de Holt-Winters y obtener los componentes model = sm.tsa.ExponentialSmoothing(values, trend=&quot;add&quot;, seasonal=&quot;add&quot;, seasonal_periods=40) ## C:\\Users\\carlos\\ANACON~1\\lib\\site-packages\\statsmodels\\tsa\\base\\tsa_model.py:471: ValueWarning: ## ## A date index has been provided, but it has no associated frequency information and so will be ignored when e.g. forecasting. results = model.fit() fitted_values = results.fittedvalues # Obtener los componentes de la descomposición residuals = values - fitted_values decomposition = sm.tsa.seasonal_decompose(values, model=&quot;additive&quot;, period=40) # Graficar los componentes plt.figure(figsize=(12, 10)) plt.subplot(4, 1, 1) plt.plot(data.index, values, label=&quot;Valores reales&quot;) plt.xlabel(&quot;Fecha&quot;) plt.ylabel(&quot;Valor&quot;) plt.title(&quot;Descomposición de Holt-Winters: Valores reales&quot;) plt.subplot(4, 1, 2) plt.plot(data.index, decomposition.trend, label=&quot;Tendencia&quot;) plt.xlabel(&quot;Fecha&quot;) plt.ylabel(&quot;Valor&quot;) plt.title(&quot;Descomposición de Holt-Winters: Tendencia&quot;) plt.subplot(4, 1, 3) plt.plot(data.index, decomposition.seasonal, label=&quot;Estacionalidad&quot;) plt.xlabel(&quot;Fecha&quot;) plt.ylabel(&quot;Valor&quot;) plt.title(&quot;Descomposición de Holt-Winters: Estacionalidad&quot;) plt.subplot(4, 1, 4) plt.plot(data.index, residuals, label=&quot;Nivel&quot;) plt.xlabel(&quot;Fecha&quot;) plt.ylabel(&quot;Valor&quot;) plt.title(&quot;Descomposición de Holt-Winters: Nivel&quot;) plt.tight_layout() plt.show() El grafico muestra la tendencia, estacionalidad y nivel sobre el precio de cierre para una ventana de 40 periodos. Se evidencia una clara tendencia al alza particularmente luego de mayo de 2022 y una estacionalidad marcada en los precios de cierre en los años evaluados. import pandas as pd import yfinance as yf import statsmodels.api as sm # Descargar los datos desde Yahoo Finance data = yf.download(&quot;COP=X&quot;, start=&quot;2017-01-01&quot;, end=&quot;2022-12-31&quot;) ## [*********************100%***********************] 1 of 1 completed data.to_csv(&quot;data.csv&quot;) # Leer los datos desde el archivo CSV data = pd.read_csv(&quot;data.csv&quot;, index_col=&quot;Date&quot;) # Convertir el índice a formato de fecha data.index = pd.to_datetime(data.index) # Obtener los valores de cierre ajustados values = data[&quot;Adj Close&quot;] # Aplicar el modelo de Holt-Winters y generar los pronósticos con intervalos de confianza model = sm.tsa.ExponentialSmoothing(values, trend=&quot;add&quot;, seasonal=&quot;add&quot;, seasonal_periods=12) ## C:\\Users\\carlos\\ANACON~1\\lib\\site-packages\\statsmodels\\tsa\\base\\tsa_model.py:471: ValueWarning: ## ## A date index has been provided, but it has no associated frequency information and so will be ignored when e.g. forecasting. results = model.fit() forecast = results.forecast(steps=120) # Pronosticar 120 días (4 meses) # Obtener las fechas del pronóstico ## C:\\Users\\carlos\\ANACON~1\\lib\\site-packages\\statsmodels\\tsa\\base\\tsa_model.py:834: ValueWarning: ## ## No supported index is available. Prediction results will be given with an integer index beginning at `start`. start_date = pd.Timestamp(&quot;2023-01-01&quot;) forecast_dates = pd.date_range(start=start_date, periods=120, freq=&#39;D&#39;) # Obtener los valores pronosticados y crear una tabla con las fechas forecast_values = forecast[:120] forecast_table = pd.DataFrame({&#39;Fecha&#39;: forecast_dates, &#39;Pronóstico&#39;: forecast_values}) print(forecast_table) ## Fecha Pronóstico ## 1564 2023-01-01 4832.944607 ## 1565 2023-01-02 4834.696338 ## 1566 2023-01-03 4844.259299 ## 1567 2023-01-04 4860.144385 ## 1568 2023-01-05 4863.939037 ## ... ... ... ## 1679 2023-04-26 5286.004950 ## 1680 2023-04-27 5287.287884 ## 1681 2023-04-28 5301.877111 ## 1682 2023-04-29 5295.367489 ## 1683 2023-04-30 5300.402856 ## ## [120 rows x 2 columns] La tabla muestra el pronóstico para 6 meses posterior a la ultima fecha de los precios de cierre considerando una ventana de 16 meses. import pandas as pd import yfinance as yf import statsmodels.api as sm import matplotlib.pyplot as plt # Descargar los datos desde Yahoo Finance data = yf.download(&quot;COP=X&quot;, start=&quot;2017-01-01&quot;, end=&quot;2022-12-31&quot;) ## [*********************100%***********************] 1 of 1 completed data.to_csv(&quot;data.csv&quot;) # Leer los datos desde el archivo CSV data = pd.read_csv(&quot;data.csv&quot;, index_col=&quot;Date&quot;) # Convertir el índice a formato de fecha data.index = pd.to_datetime(data.index) # Obtener los valores de cierre ajustados values = data[&quot;Adj Close&quot;] # Aplicar el modelo de Holt-Winters y generar los pronósticos con intervalos de confianza model = sm.tsa.ExponentialSmoothing(values, trend=&quot;add&quot;, seasonal=&quot;add&quot;, seasonal_periods=12) ## C:\\Users\\carlos\\ANACON~1\\lib\\site-packages\\statsmodels\\tsa\\base\\tsa_model.py:471: ValueWarning: ## ## A date index has been provided, but it has no associated frequency information and so will be ignored when e.g. forecasting. results = model.fit() forecast = results.forecast(steps=180) # Pronosticar 180 días (6 meses) # Obtener las fechas del pronóstico ## C:\\Users\\carlos\\ANACON~1\\lib\\site-packages\\statsmodels\\tsa\\base\\tsa_model.py:834: ValueWarning: ## ## No supported index is available. Prediction results will be given with an integer index beginning at `start`. start_date = pd.Timestamp(&quot;2023-01-01&quot;) forecast_dates = pd.date_range(start=start_date, periods=180, freq=&#39;D&#39;) # Obtener los valores pronosticados forecast_values = forecast[:180] # Crear una figura y graficar los datos originales plt.figure(figsize=(10, 6)) plt.plot(data.index, values, label=&quot;Datos originales&quot;) # Graficar los valores pronosticados plt.plot(forecast_dates, forecast_values, label=&quot;Valores pronosticados&quot;) # Configurar etiquetas y título del gráfico plt.xlabel(&quot;Fecha&quot;) plt.ylabel(&quot;Precio de cierre&quot;) plt.title(&quot;Pronóstico del precio de cierre para los primeros 6 meses de 2023&quot;) # Mostrar la leyenda plt.legend() # Mostrar el gráfico plt.show() Muestra grafíca de los precio de cierre pronosticados.A simple vista se puede observar que el metodo de Holt-Winter no parece tener buenos resultados en dicha predicción, si tan solo consideramos los valores de precio en el tiempo. "],["metodología-box-jenkins.html", "Capitulo 8 Metodología Box-Jenkins", " Capitulo 8 Metodología Box-Jenkins Paso 0: Verificar que la serie se vuelva estacionaria para aplicar modelo ARIMA correctamente. Para verificar que es estacionaria usamos prueba AD Fuller from statsmodels.tsa.stattools import adfuller data[&#39;valor_diferenciado&#39;] = data[&#39;Close&#39;].diff(55) copydata = data.dropna() resultado_adf = adfuller(copydata[&#39;valor_diferenciado&#39;]) print(&#39;Estadísticas de la prueba ADF:&#39;) ## Estadísticas de la prueba ADF: print(&#39;Valor de la estadística de prueba:&#39;, resultado_adf[0]) ## Valor de la estadística de prueba: -4.591829862369242 print(&#39;Valor p - Umbral menor a 0.05:&#39;, resultado_adf[1]) ## Valor p - Umbral menor a 0.05: 0.00013372340263588406 Nuestra diferenciación se aplicaría a 55 periodos Paso 1: Identificación - Gráficos de autocorrelación y autocorrelación parcial ACF y PACF. import matplotlib.pyplot as plt from statsmodels.graphics.tsaplots import plot_acf fig, ax = plt.subplots(2, 1, figsize=(10, 8)) ax[0].plot(copydata[&quot;valor_diferenciado&quot;]) ax[0].set_title(&#39;Serie de tiempo del índice del dólar con el peso colombiano&#39;) ax[1].acorr(copydata[&quot;valor_diferenciado&quot;], maxlags=10) ## (array([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, ## 3, 4, 5, 6, 7, 8, 9, 10]), array([0.75273421, 0.77763472, 0.80322799, 0.82740277, 0.85119328, ## 0.87748079, 0.90424636, 0.92843302, 0.95371696, 0.97590483, ## 1. , 0.97590483, 0.95371696, 0.92843302, 0.90424636, ## 0.87748079, 0.85119328, 0.82740277, 0.80322799, 0.77763472, ## 0.75273421]), &lt;matplotlib.collections.LineCollection object at 0x000002033E88A700&gt;, &lt;matplotlib.lines.Line2D object at 0x000002033E88A4F0&gt;) ax[1].set_title(&#39;Autocorrelación&#39;) plt.show() De acuerdo al gráfico anterior dejaremos autocorrelación y media movil en 1 porque es el que más se acerca a 1 o la autocorrelación más fuerte. Paso 2: Estimación - Ajustar un modelo ARIMA from statsmodels.tsa.arima.model import ARIMA #copydata = copydata.set_index(&quot;Date&quot;) copydata= copydata.to_period(&#39;D&#39;) model = ARIMA(copydata[&quot;valor_diferenciado&quot;], order=(1, 0, 1)) model_fit = model.fit() Paso 3: Diagnóstico - Verificar los residuos del modelo residuals = pd.Series(model_fit.resid) fig, ax = plt.subplots(1, 2, figsize=(12, 4)) residuals = residuals.reset_index() residuals[&quot;Date&quot;] = residuals[&quot;Date&quot;].astype(&quot;str&quot;) residuals=residuals.set_index(&quot;Date&quot;) ax[0].plot(residuals) ax[0].set_title(&#39;Residuos del modelo ARIMA&#39;) ax[1].set(ylim=(-1.5, 1.5)) ## [(-1.5, 1.5)] ax[1].set_title(&#39;Distribución de residuos&#39;) residuals.plot(kind=&#39;kde&#39;, ax=ax[1]) plt.show() No se evidencia patrones o tendencia en los residuos permitiendo validar el primer supuesto y su media parece estar cercana a 0. Sin embargo, la distribución de los residuos no es normal, lo que indica que el modelo no captura adecuadamente la estructura de la serie. De igual manera realizamos el pronóstico para comparar Paso 4 Pronóstico - Generar pronósticos futuros forecast = model_fit.forecast(steps=15) forecast = forecast.reset_index() forecast[&quot;index&quot;] = forecast[&quot;index&quot;].dt.to_timestamp() forecast = forecast.set_index(&quot;index&quot;) real = copydata.reset_index() real[&quot;Date&quot;] = real[&quot;Date&quot;].dt.to_timestamp() real = real[(real[&quot;Date&quot;] &gt; &quot;2021-05-01&quot;) &amp; (real[&quot;Date&quot;] &lt; &quot;2021-05-22&quot;)][[&quot;valor_diferenciado&quot;, &quot;Date&quot;]] real = real.set_index(&quot;Date&quot;) plt.figure(figsize=(10, 6)) plt.plot(forecast, label=&#39;Pronósticos&#39;) plt.plot(real, label=&#39;Serie de tiempo original&#39;) plt.title(&#39;Pronóstico del índice del dólar con peso Colombiano&#39;) plt.legend() plt.show() La proyección tampoco se ajusta mucho a la serie de tiempo. En conclusión, al igual que el metodo Holt-Winter, el resultado es una linea de tendencia recta y necesitamos una opción que logre predecir mejor los cambios, allí aplicaremos metricas como RSME. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
